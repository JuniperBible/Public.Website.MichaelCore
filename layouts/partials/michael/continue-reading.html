{{/*
  Template: continue-reading.html
  Purpose: Show "Continue Reading" prompt based on user's reading history

  This component displays the user's last read chapter using data stored
  in IndexedDB by reading-tracker.js. Shows nothing if no reading history.

  Usage: {{ partial "michael/continue-reading.html" . }}
*/}}
<div id="continue-reading" class="continue-reading hidden" aria-live="polite" aria-label="{{ i18n "continueReading" | default "Continue Reading" }}">
  <div class="continue-reading__content">
    <span class="continue-reading__label">{{ i18n "continueReading" | default "Continue Reading" }}</span>
    <a id="continue-reading-link" href="#" class="continue-reading__chapter">
      <span id="continue-reading-title">{{ i18n "loading" | default "Loading..." }}</span>
      <span class="continue-reading__arrow" aria-hidden="true">&rarr;</span>
    </a>
  </div>
  <button id="continue-reading-dismiss" class="continue-reading__dismiss" type="button" aria-label="Dismiss continue reading prompt">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" focusable="false" aria-hidden="true">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  </button>
</div>

<script>
(function() {
  'use strict';

  // Build a human-readable chapter title from a lastRead record.
  function buildDisplayTitle(lastRead) {
    const bookName = lastRead.bookId.charAt(0).toUpperCase() + lastRead.bookId.slice(1);
    const bible = lastRead.bibleId.toUpperCase();
    return `${bookName} ${lastRead.chapter} (${bible})`;
  }

  // Return false when lastRead is missing required fields.
  function isValidLastRead(lastRead) {
    return lastRead && lastRead.bibleId && lastRead.bookId && lastRead.chapter;
  }

  // Populate the widget elements and make the container visible.
  function showChapter(elements, lastRead) {
    const url = `/bible/${lastRead.bibleId}/${lastRead.bookId}/${lastRead.chapter}/`;
    if (window.location.pathname === url) return;

    elements.link.href = url;
    elements.title.textContent = buildDisplayTitle(lastRead);
    elements.container.classList.remove('hidden');
  }

  // Attach the dismiss button listener.
  function setupDismissButton(container, dismissBtn) {
    if (!dismissBtn) return;
    dismissBtn.addEventListener('click', () => {
      container.classList.add('hidden');
      sessionStorage.setItem('continue-reading-dismissed', 'true');
    });
  }

  // Query required DOM nodes; return null when any are absent.
  function getElements() {
    const container = document.getElementById('continue-reading');
    const link     = document.getElementById('continue-reading-link');
    const title    = document.getElementById('continue-reading-title');
    if (!container || !link || !title) return null;
    return { container, link, title };
  }

  // Core initializer - runs once ReadingTracker is present.
  function runInit() {
    const elements = getElements();
    if (!elements) return;

    if (sessionStorage.getItem('continue-reading-dismissed') === 'true') return;

    const dismissBtn = document.getElementById('continue-reading-dismiss');
    setupDismissButton(elements.container, dismissBtn);

    window.Michael.ReadingTracker.getLastRead().then(lastRead => {
      if (!isValidLastRead(lastRead)) return;
      showChapter(elements, lastRead);
    }).catch(err => {
      console.debug('Continue reading not available:', err);
    });
  }

  // Wait for ReadingTracker to be available, then delegate to runInit.
  function initContinueReading() {
    if (!window.Michael?.ReadingTracker) {
      setTimeout(initContinueReading, 100);
      return;
    }
    runInit();
  }

  // Bootstrap when the DOM is ready.
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initContinueReading);
  } else {
    initContinueReading();
  }
})();
</script>
