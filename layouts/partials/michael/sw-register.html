{{/*
  Template: sw-register.html
  Purpose: Service Worker registration script

  Features:
  - Feature detection for serviceWorker support
  - Register service worker on DOMContentLoaded
  - Handle registration success and errors gracefully
  - Only register in production environment
  - Handle service worker updates with SKIP_WAITING
  - Log useful debugging information

  Usage:
  Include this partial in baseof.html before closing </body> tag:
  {{ partial "michael/sw-register.html" . }}

  Environment Detection:
  - Checks HUGO_ENVIRONMENT to only register in production
  - Can be overridden with .Site.Params.michael.enableSW in dev
*/}}

<script>
  /**
   * Service Worker Registration
   *
   * This script registers the service worker for offline support.
   * It only runs in production or when explicitly enabled.
   */

  (function() {
    'use strict';

    // Check if service workers are supported
    if (!('serviceWorker' in navigator)) {
      console.log('[SW] Service workers not supported in this browser');
      return;
    }

    // Environment check - skip if explicitly disabled
    {{ if .Site.Params.michael.disableSW }}
    console.log('[SW] Service worker explicitly disabled via params.michael.disableSW');
    return;
    {{ end }}

    // Store reference to waiting service worker
    let waitingWorker = null;

    /**
     * Register the service worker
     */
    function registerServiceWorker() {
      navigator.serviceWorker
        .register('/sw.js', {
          scope: '/'
        })
        .then(function(registration) {
          console.log('[SW] Registration successful. Scope:', registration.scope);

          // Store registration globally for other scripts to use
          window.swRegistration = registration;

          // Check if there's already a waiting worker
          if (registration.waiting) {
            waitingWorker = registration.waiting;
            showUpdateNotification();
          }

          // Check for updates periodically
          registration.addEventListener('updatefound', function() {
            const newWorker = registration.installing;
            console.log('[SW] Update found. Installing new service worker...');

            newWorker.addEventListener('statechange', function() {
              console.log('[SW] Service worker state:', newWorker.state);

              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New service worker available and waiting
                waitingWorker = newWorker;
                console.log('[SW] New version available! Showing update notification.');
                showUpdateNotification();
              }
            });
          });

          // Check for updates every hour
          setInterval(function() {
            registration.update();
          }, 60 * 60 * 1000);

          // Initial update check
          registration.update();
        })
        .catch(function(error) {
          console.error('[SW] Registration failed:', error);
        });
    }

    /**
     * Send SKIP_WAITING message to activate the new service worker
     */
    function skipWaiting() {
      if (!waitingWorker) {
        console.warn('[SW] No waiting worker to activate');
        return;
      }

      console.log('[SW] Sending SKIP_WAITING message to service worker');
      waitingWorker.postMessage({ type: 'SKIP_WAITING' });
    }

    /**
     * Show update notification to user
     */
    function showUpdateNotification() {
      // Check if user wants notifications
      const showNotification = localStorage.getItem('sw-show-update-notification') !== 'false';

      if (!showNotification) {
        // If notifications are disabled, auto-update silently
        skipWaiting();
        return;
      }

      // Don't show duplicate banners
      if (document.getElementById('sw-update-banner')) {
        return;
      }

      // Create notification banner
      const banner = document.createElement('div');
      banner.id = 'sw-update-banner';
      banner.className = 'sw-update-banner';
      banner.setAttribute('role', 'alert');
      banner.setAttribute('aria-live', 'polite');

      // Create content container
      const content = document.createElement('div');
      content.className = 'sw-update-banner__content';

      // Create icon
      const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      icon.setAttribute('class', 'sw-update-banner__icon');
      icon.setAttribute('fill', 'none');
      icon.setAttribute('viewBox', '0 0 24 24');
      icon.setAttribute('stroke', 'currentColor');
      icon.setAttribute('focusable', 'false');
      icon.setAttribute('aria-hidden', 'true');
      const iconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      iconPath.setAttribute('stroke-linecap', 'round');
      iconPath.setAttribute('stroke-linejoin', 'round');
      iconPath.setAttribute('stroke-width', '2');
      iconPath.setAttribute('d', 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15');
      icon.appendChild(iconPath);

      // Create text container
      const textContainer = document.createElement('div');
      textContainer.className = 'sw-update-banner__text';

      const titleDiv = document.createElement('div');
      titleDiv.className = 'sw-update-banner__title';
      titleDiv.textContent = {{ i18n "swUpdateAvailable" | default "Update Available" | jsonify }};

      const messageDiv = document.createElement('div');
      messageDiv.className = 'sw-update-banner__message';
      messageDiv.textContent = {{ i18n "swUpdateMessage" | default "A new version is ready to install." | jsonify }};

      textContainer.appendChild(titleDiv);
      textContainer.appendChild(messageDiv);
      content.appendChild(icon);
      content.appendChild(textContainer);

      // Create actions container
      const actions = document.createElement('div');
      actions.className = 'sw-update-banner__actions';

      const reloadBtn = document.createElement('button');
      reloadBtn.id = 'sw-update-reload-btn';
      reloadBtn.className = 'sw-update-banner__reload-btn';
      reloadBtn.type = 'button';
      reloadBtn.textContent = {{ i18n "swUpdateNow" | default "Update Now" | jsonify }};

      const dismissBtn = document.createElement('button');
      dismissBtn.id = 'sw-update-dismiss-btn';
      dismissBtn.className = 'sw-update-banner__dismiss-btn';
      dismissBtn.type = 'button';
      dismissBtn.setAttribute('aria-label', {{ i18n "swDismissUpdate" | default "Dismiss update notification" | jsonify }});

      const dismissIcon = document.createElement('span');
      dismissIcon.setAttribute('aria-hidden', 'true');
      dismissIcon.innerHTML = '&times;';
      dismissBtn.appendChild(dismissIcon);

      actions.appendChild(reloadBtn);
      actions.appendChild(dismissBtn);

      banner.appendChild(content);
      banner.appendChild(actions);
      document.body.appendChild(banner);

      // Move focus to the reload button so screen readers announce the banner
      reloadBtn.focus();

      // Handle reload button click
      reloadBtn.addEventListener('click', function() {
        // Send skip waiting and reload when the new SW takes control
        skipWaiting();
      });

      // Handle dismiss button click
      dismissBtn.addEventListener('click', function() {
        banner.remove();
      });

      // Auto-dismiss after 60 seconds (but update will still be pending)
      setTimeout(function() {
        const existingBanner = document.getElementById('sw-update-banner');
        if (existingBanner) {
          existingBanner.remove();
        }
      }, 60000);
    }

    /**
     * Handle controller change (new service worker activated)
     * This fires when SKIP_WAITING causes the new SW to take control
     */
    navigator.serviceWorker.addEventListener('controllerchange', function() {
      console.log('[SW] Controller changed. Reloading page to use new version.');
      // Reload the page to use the new service worker
      window.location.reload();
    });

    /**
     * Listen for messages from the service worker
     */
    navigator.serviceWorker.addEventListener('message', function(event) {
      console.log('[SW] Message received from service worker:', event.data);

      // Handle different message types
      if (event.data && event.data.type === 'CACHE_UPDATED') {
        console.log('[SW] Cache has been updated');
      }
    });

    /**
     * Initialize on DOMContentLoaded
     */
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', registerServiceWorker);
    } else {
      // DOM already loaded
      registerServiceWorker();
    }

    // Expose skipWaiting for manual triggering if needed
    window.Michael = window.Michael || {};
    window.Michael.SWUpdate = {
      skipWaiting: skipWaiting,
      checkForUpdate: function() {
        if (window.swRegistration) {
          window.swRegistration.update();
        }
      }
    };

  })();
</script>
