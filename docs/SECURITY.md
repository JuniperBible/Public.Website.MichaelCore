# Security Documentation

This document describes the security model, protections, and best practices for the Michael Hugo Bible Module.

---

## Table of Contents

1. [Security Model Overview](#security-model-overview)
2. [Content Security Policy](#content-security-policy)
3. [Input Validation](#input-validation)
4. [XSS Prevention](#xss-prevention)
5. [Third-Party Dependencies](#third-party-dependencies)
6. [Service Worker Security](#service-worker-security)
7. [Reporting Security Issues](#reporting-security-issues)

---

## Security Model Overview

### Architecture Characteristics

**Client-Side Only Application**

- No server-side code execution
- No backend API or database
- All processing occurs in the browser
- Static file hosting only required

**No User Authentication**

- Public content only (Bible texts are in the public domain or openly licensed)
- No user accounts, sessions, or authentication tokens
- No personally identifiable information (PII) collected or stored
- No login credentials to protect

**Limited Data Storage**

- Browser cache managed by Service Worker (see [Service Worker Security](#service-worker-security))
- localStorage used only for UI preferences (selected translations, last-viewed chapter)
- No sensitive data stored client-side
- All cached data can be safely cleared without user data loss

**Defense in Depth**

- Content Security Policy (CSP) enforced via meta tag
- XSS prevention through HTML escaping
- Input validation on all user-provided data
- No eval() or Function() constructors used
- No inline event handlers in HTML

---

## Content Security Policy

### CSP Implementation

The application enforces a strict Content Security Policy defined in `/home/justin/Programming/Workspace/michael/layouts/_default/baseof.html` (line 23):

```html
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self';
               style-src 'self' 'unsafe-inline';
               img-src 'self' data:;
               connect-src 'self';
               font-src 'self';
               frame-ancestors 'none';
               base-uri 'self';
               form-action 'self';">
```

### CSP Directive Breakdown

| Directive | Value | Purpose |
|-----------|-------|---------|
| `default-src` | `'self'` | Default policy: only load resources from same origin |
| `script-src` | `'self'` | JavaScript must come from same origin (no inline scripts, no external CDNs) |
| `style-src` | `'self' 'unsafe-inline'` | Stylesheets from same origin; inline styles allowed for Hugo fingerprinting |
| `img-src` | `'self' data:` | Images from same origin or data URIs (for embedded icons/SVGs) |
| `connect-src` | `'self'` | AJAX/fetch requests limited to same origin (Bible chapter data) |
| `font-src` | `'self'` | Web fonts must be self-hosted |
| `frame-ancestors` | `'none'` | Prevent clickjacking (cannot be embedded in iframes) |
| `base-uri` | `'self'` | Restrict `<base>` tag to prevent URL injection |
| `form-action` | `'self'` | Forms can only submit to same origin |

### CSP Exceptions Explained

**Why `'unsafe-inline'` for styles?**

- Hugo's asset pipeline uses inline `integrity` attributes for SRI (Subresource Integrity)
- Hugo's fingerprinting requires dynamically generated style tags
- Inline styles are lower risk than inline scripts (cannot execute arbitrary code)
- **Alternative for production:** Move CSP to HTTP headers and use nonces for inline styles

**Why no nonces or hashes?**

- Static site generation makes nonce-based CSP impractical (nonces must change per request)
- All JavaScript is external files (`script-src 'self'`), so no inline script hashes needed
- For HTTP header-based CSP in production, consider using nonces generated by your CDN/hosting provider

### CSP Compliance Verification

All JavaScript files avoid CSP-violating patterns:
- No `eval()` or `new Function()` usage
- No `javascript:` URLs
- No inline event handlers (`onclick`, `onerror`, etc.)
- No `setTimeout/setInterval` with string arguments
- All event listeners attached via `addEventListener()`

**Verified files:**

- `/home/justin/Programming/Workspace/michael/assets/js/bible-search.js` - ✅ CSP-compliant
- `/home/justin/Programming/Workspace/michael/assets/js/strongs.js` - ✅ CSP-compliant
- `/home/justin/Programming/Workspace/michael/assets/js/parallel.js` - ✅ CSP-compliant
- `/home/justin/Programming/Workspace/michael/static/sw.js` - ✅ CSP-compliant
- `/home/justin/Programming/Workspace/michael/assets/js/michael/dom-utils.js` - ✅ CSP-compliant

---

## Input Validation

### URL Parameter Handling

**Search Query Parameters** (`bible-search.js`)

Location: `/home/justin/Programming/Workspace/michael/assets/js/bible-search.js` lines 154-169

```javascript
function initFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const q = params.get('q');
  const bible = params.get('bible');

  if (q) queryInput.value = q;  // Assigned to input.value (safe, auto-escaped)
  if (bible && bibleSelect.querySelector(`option[value="${bible}"]`)) {
    bibleSelect.value = bible;  // Validated against available options
  }
  // ...
}
```

**Validation measures:**

- Bible ID validated against available options in dropdown (whitelist validation)
- Query string assigned to `input.value` (browser auto-escapes)
- Case-sensitive and whole-word flags validated as boolean ('1' or absent)
- No URL parameters directly inserted into HTML

**Comparison View Parameters** (`parallel.js`)

Location: `/home/justin/Programming/Workspace/michael/assets/js/parallel.js` lines 951-1003

```javascript
function restoreState() {
  const params = new URLSearchParams(window.location.search);
  const biblesParam = params.get('bibles');
  const refParam = params.get('ref');

  if (biblesParam) {
    selectedTranslations = biblesParam.split(',').filter(id =>
      bibleData?.bibles?.some(b => b.id === id)  // Whitelist validation
    );
  }
  // ...
}
```

**Validation measures:**

- Bible IDs filtered against known translations in metadata (whitelist)
- Book IDs validated against available books
- Chapter/verse numbers parsed as integers with fallback to 0
- Invalid references ignored rather than throwing errors

### Search Query Sanitization

**Strong's Number Validation** (`bible-search.js` lines 46-52)

```javascript
const STRONGS_PATTERN = /^[HG]\d{1,5}$/i;
```

**Validation:**

- Must start with 'H' or 'G' (Hebrew/Greek)
- Followed by 1-5 digits only
- Case-insensitive match
- Invalid patterns treated as regular text search

**Phrase Search Detection** (`bible-search.js` lines 54-61)

```javascript
const PHRASE_PATTERN = /^"(.+)"$/;
```

**Validation:**

- Quoted strings detected and extracted
- Inner content still HTML-escaped before display
- No special regex characters in the pattern itself

### HTML Escaping Practices

**Universal HTML Escaping Function** (`bible-search.js` lines 90-94)

```javascript
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;  // Browser auto-escapes when assigned to textContent
  return div.innerHTML;   // Returns escaped string
}
```

**How it works:**
1. Creates temporary DOM element
2. Assigns string to `textContent` (browser automatically escapes `<`, `>`, `&`, `"`, `'`)
3. Reads back `innerHTML` to get escaped version
4. Returns safe HTML string

**Character escape mappings:**

- `<` → `&lt;`
- `>` → `&gt;`
- `&` → `&amp;`
- `"` → `&quot;`
- `'` → `&#39;`

---

## XSS Prevention

### XSS Vulnerability History

**Critical Fix (December 2024)** - `bible-search.js` line 404-408

Prior to this fix, the `highlightMatches()` function was vulnerable to XSS attacks through malicious search queries or verse content. The vulnerability was patched by escaping HTML before applying regex highlighting.

**Before (vulnerable):**
```javascript
// VULNERABLE: Applied regex directly to unescaped text
const regex = new RegExp(`(${escapeRegex(searchTerm)})`, flags);
return text.replace(regex, '<mark>$1</mark>');  // XSS if text contains <script>
```

**After (secure):**
```javascript
// SECURE: Escape HTML FIRST, then apply highlighting
const escapedText = escapeHtml(text);        // Convert < to &lt;
const escapedTerm = escapeHtml(searchTerm);
const regex = new RegExp(`(${escapeRegex(escapedTerm)})`, flags);
return escapedText.replace(regex, '<mark>$1</mark>');  // Safe
```

**Attack example (now prevented):**
```javascript
// Malicious search query
searchQuery = '<script>alert("XSS")</script>';

// Old code would produce:
"<mark><script>alert("XSS")</script></mark>"  // EXECUTES!

// New code produces:
"<mark>&lt;script&gt;alert("XSS")&lt;/script&gt;</mark>"  // SAFE
```

### innerHTML Usage Audit

**Files using innerHTML (all verified safe):**

1. **bible-search.js** (line 477, 641, 656)
   - ✅ Line 477: Controlled loading indicator (static HTML, no user input)
   - ✅ Line 641: Search results with escaped content (`highlightMatches` uses `escapeHtml`)
   - ✅ Line 656: Status message (static string interpolation, no user input)

2. **strongs.js** (line 111, 358)
   - ✅ Line 111: Static tooltip structure (no user input)
   - ✅ Line 358: Definition display using `escapeHtml()` on all user/data content

3. **parallel.js** (line 691, 707, 1218, 1221)
   - ✅ All instances use either static HTML or content processed through `escapeHtml()`
   - ✅ Translation comparison uses TextCompare library's built-in escaping

### Safe DOM Manipulation Patterns

**Preferred methods (in order of safety):**

1. **textContent** (safest - no HTML parsing)
```javascript
element.textContent = userInput;  // Always safe
```

2. **createElement + appendChild** (safe - explicit DOM construction)
```javascript
const span = document.createElement('span');
span.className = 'verse-num';
span.textContent = verseNumber;
parent.appendChild(span);
```

3. **innerHTML with escaped content** (safe if properly escaped)
```javascript
element.innerHTML = `<mark>${escapeHtml(userInput)}</mark>`;
```

**Unsafe patterns (never used in this codebase):**
```javascript
// NEVER DO THIS:
element.innerHTML = userInput;  // XSS vulnerability
element.outerHTML = userInput;  // XSS vulnerability
document.write(userInput);      // XSS vulnerability + deprecated
```

### Strong's Number Tooltips

**XSS Prevention in strongs.js** (lines 340-356)

All Strong's definition data is escaped before insertion:

```javascript
if (def.lemma) {
  html += `<p class="strongs-lemma"><strong>Lemma:</strong> ${escapeHtml(def.lemma)}`;
  if (def.xlit) {
    html += ` (${escapeHtml(def.xlit)})`;  // Transliteration escaped
  }
  if (def.pron) {
    html += ` <em>[${escapeHtml(def.pron)}]</em>`;  // Pronunciation escaped
  }
  html += '</p>';
}
```

**Why this matters:**

- Strong's data comes from external JSON files
- Could potentially contain malicious content if data source compromised
- Escaping ensures even compromised data cannot execute scripts

---

## Third-Party Dependencies

### Runtime Dependencies

**Zero external runtime dependencies**

- No jQuery, React, Vue, or other frameworks
- No CDN-hosted libraries
- All JavaScript written in vanilla ES6+
- Reduces attack surface (no third-party supply chain risk)

### Optional External Links

**Blue Letter Bible** (referenced in `strongs.js` lines 38-41)

```javascript
const STRONGS_URLS = {
  hebrew: 'https://www.blueletterbible.org/lexicon/h',
  greek: 'https://www.blueletterbible.org/lexicon/g'
};
```

**Security characteristics:**

- External links open in new tab (`target="_blank"`)
- Include `rel="noopener"` to prevent `window.opener` access
- Used only for "View Full Entry" links (user-initiated navigation)
- No data sent to Blue Letter Bible (passive link only)
- No tracking or analytics embedded

### SWORD Module Provenance

**Bible text data sources:**

All Bible translations are derived from SWORD Project modules:
- Source: [CrossWire Bible Society](https://crosswire.org/sword/)
- Format: OSIS XML converted to JSON
- Licenses: Public domain or open licenses (see `/content/licenses/`)
- Integrity: SWORD modules are cryptographically signed by maintainers

**Data integrity verification:**

- Bible data is static JSON (generated at build time)
- Served with Subresource Integrity (SRI) hashes via Hugo fingerprinting
- Any modification to data files breaks SRI and fails to load
- No runtime data modification or injection possible

**Bible data pipeline:**
1. SWORD modules downloaded from CrossWire
2. Converted to OSIS XML
3. Processed into normalized JSON format
4. Validated against JSON schemas (`/static/schemas/`)
5. Fingerprinted with SHA-256 hashes (Hugo asset pipeline)
6. Served as immutable static files

---

## Service Worker Security

### Same-Origin Policy Enforcement

**Service Worker** (`/home/justin/Programming/Workspace/michael/static/sw.js` lines 136-139)

```javascript
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Only handle same-origin requests
  if (url.origin !== self.location.origin) {
    return;  // External requests bypass service worker
  }
  // ...
});
```

**Security guarantees:**

- Service Worker only intercepts same-origin requests
- External API calls (if any) bypass the Service Worker entirely
- No cross-origin data caching
- No CORS bypass or proxy functionality

### Cache-Only Same-Origin Content

**Caching strategy** (`sw.js` lines 142-154)

```javascript
if (isStaticAsset(url)) {
  event.respondWith(cacheFirstStrategy(request, SHELL_CACHE));
} else if (isChapterPage(url)) {
  event.respondWith(networkFirstStrategy(request, CHAPTERS_CACHE));
} else if (isNavigationRequest(request)) {
  event.respondWith(navigationStrategy(request));
}
```

**Cache segmentation:**

- **Shell cache**: Static assets (CSS, JS, fonts) from same origin only
- **Chapters cache**: Bible chapter pages from same origin only
- **No external content cached**: CDN resources, images, etc. never cached

**Cache validation:**
```javascript
function isChapterPage(url) {
  // Pattern: /bible/{bible}/{book}/{chapter}/
  const chapterPattern = /^\/bible\/[^/]+\/[^/]+\/\d+\/?$/;
  return chapterPattern.test(url.pathname);
}
```

### No External API Calls

**Current implementation:**

- No external fetch requests made by service worker
- All Bible data served from static JSON files on same origin
- Future API integrations (if any) would require explicit security review

**Future considerations:**
If external APIs are added (e.g., for Strong's definitions), they must:
1. Use HTTPS only
2. Implement CSP `connect-src` whitelist
3. Validate and sanitize all API responses
4. Handle CORS properly
5. Not cache API responses with sensitive data

### Version-Controlled Updates

**Cache versioning** (`sw.js` lines 15-18)

```javascript
const CACHE_VERSION = '1';
const SHELL_CACHE = `michael-shell-v${CACHE_VERSION}`;
const CHAPTERS_CACHE = `michael-chapters-v${CACHE_VERSION}`;
```

**Update mechanism:**
1. Increment `CACHE_VERSION` in `sw.js`
2. New service worker installs with new cache names
3. Old caches automatically deleted on activation (lines 97-125)
4. Users receive updated content without manual cache clearing

**Security benefits:**

- Prevents cache poisoning persistence
- Forces refresh of potentially compromised cached content
- Ensures security patches propagate to all users
- No user intervention required for security updates

---

## Reporting Security Issues

### Contact Information

**For security vulnerabilities, please contact:**

- **Project maintainer:** Focus with Justin
- **GitHub Issues:** [https://github.com/focuswithjustin/michael](https://github.com/focuswithjustin/michael) (for non-sensitive issues)
- **Email:** For sensitive security issues, please use GitHub Security Advisories (private disclosure)

### Responsible Disclosure Process

We follow coordinated vulnerability disclosure:

**Step 1: Initial Report**

- Use GitHub Security Advisories for private disclosure
- Include detailed description of vulnerability
- Provide proof-of-concept code if applicable
- Suggest a fix if you have one

**Step 2: Acknowledgment**

- We will acknowledge receipt within 48 hours
- Confirm whether issue is accepted as a security vulnerability
- Provide estimated timeline for fix

**Step 3: Investigation**

- We will investigate and reproduce the issue
- Develop and test a fix
- Create updated documentation if needed

**Step 4: Disclosure**

- Coordinate public disclosure timeline with reporter
- Aim for fix deployment before public disclosure
- Credit reporter in release notes (unless anonymous)
- Publish security advisory with CVE if applicable

**Step 5: Resolution**

- Deploy fix to production
- Notify users via release notes and README
- Update CHANGELOG.md with security fix details

### What to Report

**Please report:**

- XSS vulnerabilities (despite our extensive escaping)
- CSP bypass techniques
- Service Worker cache poisoning
- Input validation bypasses
- Potential for code injection
- Unintended data exposure
- Any security misconfiguration

**No need to report:**

- Missing HTTPS (expected for local dev - deployment responsibility)
- Missing security headers on static hosting (hosting provider responsibility)
- Theoretical attacks requiring physical device access
- Social engineering attacks (user education issue)

### Out of Scope

The following are not considered security vulnerabilities:

- **Lack of user authentication** - By design (public content)
- **Client-side data storage** - Only non-sensitive UI preferences
- **Missing DNSSEC** - Deployment/hosting responsibility
- **Verbose error messages** - No sensitive data exposed
- **Missing rate limiting** - Static site has no API to abuse

### Security Update Policy

- **Critical vulnerabilities:** Patched within 24-48 hours
- **High severity:** Patched within 1 week
- **Medium severity:** Patched in next scheduled release
- **Low severity:** May be deferred to avoid disruption

---

## Additional Security Resources

### Related Documentation

- **Content Security Policy:** See CSP section in this document
- **Data Formats:** `/home/justin/Programming/Workspace/michael/docs/DATA-FORMATS.md`
- **Architecture:** `/home/justin/Programming/Workspace/michael/docs/ARCHITECTURE.md`
- **Service Worker:** `/home/justin/Programming/Workspace/michael/docs/SERVICE-WORKER.md`

### Security Best Practices for Deployment

**For production deployments, we recommend:**

1. **Enable HTTPS** (required for Service Worker)
2. **Add security headers** (CSP, HSTS, X-Frame-Options, etc.)
3. **Use Subresource Integrity** (SRI) for Hugo assets (already configured)
4. **Enable CORS** only if needed for external integration
5. **Implement CSP reporting** (report-uri directive)
6. **Regular dependency audits** (even though we have zero runtime dependencies)
7. **Monitor Hugo security advisories** (static site generator updates)

### Security Audit History

- **December 2024:** XSS vulnerability patched in `bible-search.js`
- **December 2024:** Complete innerHTML usage audit (all instances verified safe)
- **January 2025:** CSP meta tag implemented and tested
- **January 2025:** Input validation review completed

---

## Conclusion

The Michael Bible Module follows security best practices for client-side applications:

- ✅ **CSP-protected** - Strict Content Security Policy prevents unauthorized script execution
- ✅ **XSS-hardened** - All user input and external data properly escaped
- ✅ **Input-validated** - URL parameters and search queries sanitized
- ✅ **Dependency-free** - Zero external runtime dependencies to minimize supply chain risk
- ✅ **Same-origin only** - Service Worker only caches same-origin content
- ✅ **Statically generated** - No server-side attack surface
- ✅ **Publicly auditable** - Open source code available for security review

For questions or security concerns, please refer to the [Reporting Security Issues](#reporting-security-issues) section.

---

**Last updated:** 2025-01-25
**Document version:** 1.0.0
